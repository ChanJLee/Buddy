package com.chan.buddy.utility;import android.graphics.Bitmap;import android.support.annotation.NonNull;import com.chan.buddy.zxing.RGBLuminanceSource;import com.chan.buddy.zxing.decoding.DecodeFormatManager;import com.google.zxing.BarcodeFormat;import com.google.zxing.BinaryBitmap;import com.google.zxing.DecodeHintType;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatReader;import com.google.zxing.MultiFormatWriter;import com.google.zxing.Result;import com.google.zxing.WriterException;import com.google.zxing.common.BitMatrix;import com.google.zxing.common.HybridBinarizer;import com.google.zxing.qrcode.QRCodeReader;import java.util.Hashtable;import java.util.Vector;public final class QRUtility {	private static final int BLACK = 0xff000000;	private static MultiFormatReader s_multiFormatReader;	private static Hashtable<DecodeHintType, Object> s_decodeHints;	private static Hashtable<EncodeHintType, String> s_encodeHints;	private static Hashtable<EncodeHintType, String> getEncodeHints(){		if(s_encodeHints == null){			s_encodeHints = new Hashtable<EncodeHintType, String>();			s_encodeHints.put(EncodeHintType.CHARACTER_SET, "UTF8");		}		return s_encodeHints;	}	public static Bitmap createQRCode(String str,int widthAndHeight) throws WriterException {		Hashtable<EncodeHintType, String> hints = getEncodeHints();		BitMatrix matrix = new MultiFormatWriter().encode(str,				BarcodeFormat.QR_CODE, widthAndHeight, widthAndHeight);		int width = matrix.getWidth();		int height = matrix.getHeight();		int[] pixels = new int[width * height];		for (int y = 0; y < height; y++) {			for (int x = 0; x < width; x++) {				if (matrix.get(x, y)) {					pixels[y * width + x] = BLACK;				}			}		}		Bitmap bitmap = Bitmap.createBitmap(width, height,				Bitmap.Config.ARGB_8888);		bitmap.setPixels(pixels, 0, width, 0, 0, width, height);		return bitmap;	}	/**	 * 从图片中识二维码	 * @param bitmap	 * @return	 */	public static Result decodeFromBitmap(@NonNull Bitmap bitmap) {        Result result = null;        Hashtable<EncodeHintType, String> hints = new Hashtable<EncodeHintType, String>();        hints.put(EncodeHintType.CHARACTER_SET, "UTF8");        RGBLuminanceSource source = new RGBLuminanceSource(bitmap);        BinaryBitmap bitmap1 = new BinaryBitmap(new HybridBinarizer(source));        QRCodeReader reader2 = new QRCodeReader();        try {            result = reader2.decode(bitmap1, hints);        } catch (Exception e) {}        return result;    }	private static MultiFormatReader getMultiFormatReader(){		if(s_multiFormatReader == null) {			s_multiFormatReader = new MultiFormatReader();			// 解码的参数			Hashtable<DecodeHintType, Object> hints = getDecodeHints();			// 设置解析配置参数			s_multiFormatReader.setHints(hints);		}		return s_multiFormatReader;	}		private static Hashtable<DecodeHintType, Object> getDecodeHints(){		if(s_decodeHints == null) {			// 解码的参数			s_decodeHints = new Hashtable<DecodeHintType, Object>(2);			// 可以解析的编码类型			Vector<BarcodeFormat> decodeFormats = new Vector<BarcodeFormat>();			// 这里设置可扫描的类型，我这里选择了都支持			decodeFormats.addAll(DecodeFormatManager.ONE_D_FORMATS);			decodeFormats.addAll(DecodeFormatManager.QR_CODE_FORMATS);			decodeFormats.addAll(DecodeFormatManager.DATA_MATRIX_FORMATS);			// 设置可能的格式			s_decodeHints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);			// 设置继续的字符编码格式为UTF8		//	s_decodeHints.put(DecodeHintType.CHARACTER_SET, "UTF8");		}		return s_decodeHints;	}}